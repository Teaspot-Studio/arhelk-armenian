
==================== FINAL INTERFACE ====================
2015-11-03 17:00:09.641628 UTC

interface arhel_5l4tN5K8mLn1X8xpt1McF3:Arhelk.Russian.Lemma.Data.Adverb 7102
  interface hash: d82b6548d6a2cdee73d4fc3daf634710
  ABI hash: 36e92ebb6de25e7b5e9fcfdcab0576d1
  export-list hash: c8c6c929c9840d29b4e413080bea576c
  orphan hash: 1367eb1fba6d62c16c4ac9ec53290cf1
  flag hash: 0fec855f7cc196a33e836a863eef834f
  sig of: Nothing
  used TH splices: True
  where
exports:
  Arhelk.Russian.Lemma.Data.Adverb.adverbDegree
  Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties{Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties Arhelk.Russian.Lemma.Data.Adverb._adverbDegree}
module dependencies: Arhelk.Russian.Lemma.Data.Adjective
                     Arhelk.Russian.Lemma.Data.Common
                     Arhelk.Russian.Lemma.Data.Substantive
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 base-compat-0.8.2@basec_D4gHocz8sOX8PHzFB3nfQT
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      generic-deriving-1.8.0@gener_1Q2nStr4JSvHfQMGPOhz3e
                      ghc-prim-0.4.0.0 hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy
                      integer-gmp-1.0.0.0
                      lens-family-th-0.4.1.0@lensf_1BXbC5Dg0C5GlgOx3ZVBtX
                      lens-family-core-1.2.0@lensf_41RJsMbLUP4I9prGLUphsy
                      lens-family-1.2.0@lensf_BcsUcH7SCv1L4ogXuYAwHp
                      lens-simple-0.1.0.8@lenss_3ClGSemuCIs1em35IPgh6B
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      text-show-2@texts_6msSD0wSAlK5unkkd9ynxr
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Control.Applicative
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Control.Concurrent
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Control.Exception
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Control.Monad.ST
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Array
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Bool
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.ByteString
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Char
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Complex
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Data
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Dynamic
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Either
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Fixed
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Floating
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Functor.Identity
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Integral
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.List
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Maybe
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Monoid
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Ord
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Proxy
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Ratio
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Text
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Tuple
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Type.Coercion
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Type.Equality
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Typeable
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Version
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Data.Void
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Foreign.C.Types
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Foreign.Ptr
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.Event
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.Fingerprint
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.Generics
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.RTS.Flags
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.StaticPtr
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.Stats
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.GHC.TypeLits
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Numeric.Natural
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.System.Exit
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.System.IO
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.System.Posix.Types
         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Text.Read
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics base-4.8.1.0:GHC.TypeLits
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO:Data.List.NonEmpty
                         semigroups-0.16.2.2@semig_509rjK42Yeb8JAwFst5KmO:Data.Semigroup
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Classes
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashMap.Base
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashSet
import  -/  Arhelk.Russian.Lemma.Data.Adjective 1051c98a64f2248696bb68d7ea004fb2
  exports: 615065f5a22d20385d0277dc16e73375
  AdjectiveDegree 31f2be2af69dd58963121f7ebdafd7b7
import  -/  base-4.8.1.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.1.0:Data.Monoid bd73caba6e77f9944cb89ef5bec300c6
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  lens-family-th-0.4.1.0@lensf_1BXbC5Dg0C5GlgOx3ZVBtX:Lens.Family2.TH 7cc9ba1c82f1aa0ef8b5e3d05747f5ba
import  -/  lens-simple-0.1.0.8@lenss_3ClGSemuCIs1em35IPgh6B:Lens.Simple 0415aae47fc565920c4518de36a394c8
import  -/  text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow f98816fc41e1809d42ba206af16c7297
import  -/  text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Classes 2c021982bdb0927c661f3d4c9188a464
import  -/  text-show-2@texts_6msSD0wSAlK5unkkd9ynxr:TextShow.Utils c7b192e03bc8b48d2b27d4f2a73e0aa2
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fEqAdverbProperties ::
    GHC.Classes.Eq Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                  Arhelk.Russian.Lemma.Data.Adverb.$fEqAdverbProperties_$c==
                  Arhelk.Russian.Lemma.Data.Adverb.$fEqAdverbProperties_$c/= -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fEqAdverbProperties_$c/= ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   w1 :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case w of ww { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww1 ->
                 case w1 of ww2 { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww3 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$w$c/= ww1 ww3 } }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fEqAdverbProperties_$c== ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   w1 :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case w of ww { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww1 ->
                 case w1 of ww2 { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww3 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$fEqAdverbProperties_$s$fEqMaybe_$c==
                   ww1
                   ww3 } }) -}
b064b99df44d478e73597539697e1bb9
  $fEqAdverbProperties_$s$fEqMaybe_$c== ::
    GHC.Base.Maybe Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Base.Maybe
         Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: GHC.Base.Maybe
                           Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
                   ds1 :: GHC.Base.Maybe
                            Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a3
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> Arhelk.Russian.Lemma.Data.Adjective.$fEqAdjectiveDegree_$c==
                             a3
                             b1 } }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fMonoidAdverbProperties ::
    GHC.Base.Monoid Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                  Arhelk.Russian.Lemma.Data.Adverb.$fMonoidAdverbProperties_$cmempty
                  Arhelk.Russian.Lemma.Data.Adverb.$fMonoidAdverbProperties_$cmappend
                  Arhelk.Russian.Lemma.Data.Adverb.$fMonoidAdverbProperties_$cmconcat -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fMonoidAdverbProperties_$cmappend ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><L,1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ a3 :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   b :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   (case a3 of wild { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds ->
                    case ds of wild1 {
                      GHC.Base.Nothing
                      -> case b of wild2 { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds1 ->
                         ds1 }
                      GHC.Base.Just ipv -> wild1 } })) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fMonoidAdverbProperties_$cmconcat ::
    [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties] ->
                 case Arhelk.Russian.Lemma.Data.Adverb.$wgo w of ww { (##) ww1 ->
                 Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww1 }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fMonoidAdverbProperties_$cmempty ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   (GHC.Base.Nothing
                      @ Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree)) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fShowAdverbProperties ::
    GHC.Show.Show Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                  Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties_$cshowsPrec
                  Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties_$cshow
                  Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties_$cshowList -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fShowAdverbProperties1 ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case w of ww { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww1 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$w$cshowsPrec 0 ww1 }) -}
7275cafc434ec16325bd548dfca35992
  $fShowAdverbProperties2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
acabdc941b24bd810ef1165ab2e1a649
  $fShowAdverbProperties3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_adverbDegree = "#) -}
3d217cf73df16776f07acf6c01067d33
  $fShowAdverbProperties4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AdverbProperties {"#) -}
b61c92c95d273cd1f8a3e71060b34018
  $fShowAdverbProperties5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
88716a0988ff46293991e03263f2b304
  $fShowAdverbProperties6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2ff78c0a7153b303a60965d8d27c083a
  $fShowAdverbProperties7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   GHC.Show.$fShowMaybe3
                   Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties6) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fShowAdverbProperties_$cshow ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case w of ww { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww1 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$w$cshow ww1 }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fShowAdverbProperties_$cshowList ::
    [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
    -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties1) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fShowAdverbProperties_$cshowsPrec ::
    GHC.Types.Int
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ww3 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$w$cshowsPrec ww1 ww3 } }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fTextShowAdverbProperties ::
    TextShow.Classes.TextShow
      Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                  Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_$s$dmshowbPrec
                  Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_$cshowb
                  Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_$cshowbList -}
de08a05d8647d569f31a32cbb35047d3
  $fTextShowAdverbProperties1 ::
    (Data.Text.Internal.Builder.Buffer s
     -> GHC.ST.ST s [Data.Text.Internal.Text])
    -> Data.Text.Internal.Builder.Buffer s
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s, [Data.Text.Internal.Text] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S,1*U(U,U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   w :: Data.Text.Internal.Builder.Buffer s
                        -> GHC.ST.ST s [Data.Text.Internal.Text]
                   w1 :: Data.Text.Internal.Builder.Buffer s
                   w2 :: GHC.Prim.State# s[OneShot] ->
                 case w1 of ww { Data.Text.Internal.Builder.Buffer ww1 ww2 ww3 ww4 ->
                 Arhelk.Russian.Lemma.Data.Adverb.$wa @ s w ww1 ww2 ww3 ww4 w2 }) -}
af453ab62c5ff4767680ce4da89273b3
  $fTextShowAdverbProperties2 ::
    (Data.Text.Internal.Builder.Buffer s
     -> GHC.ST.ST s [Data.Text.Internal.Text])
    -> Data.Text.Internal.Builder.Buffer s
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s, [Data.Text.Internal.Text] #)
  {- Arity: 3,
     Unfolding: (\ @ s
                   k :: Data.Text.Internal.Builder.Buffer s
                        -> GHC.ST.ST s [Data.Text.Internal.Text]
                   ds1 :: Data.Text.Internal.Builder.Buffer s
                   eta :: GHC.Prim.State# s[OneShot] ->
                 case ds1 of wild1 { Data.Text.Internal.Builder.Buffer dt dt1 dt2 dt3 ->
                 letrec {
                   $wa3 :: GHC.Prim.MutableByteArray# s
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> [GHC.Types.Char]
                           -> GHC.Prim.State# s
                           -> (# GHC.Prim.State# s, [Data.Text.Internal.Text] #)
                     {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><S,1*U><L,U>,
                        Inline: [0] -}
                   = \ ww :: GHC.Prim.MutableByteArray# s
                       ww1 :: GHC.Prim.Int#
                       ww2 :: GHC.Prim.Int#
                       ww3 :: GHC.Prim.Int#
                       w :: [GHC.Types.Char]
                       w1 :: GHC.Prim.State# s[OneShot] ->
                     case w of wild2 {
                       []
                       -> (k (Data.Text.Internal.Builder.Buffer @ s ww ww1 ww2 ww3))
                            `cast`
                          (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R)
                            w1
                       : ipv4 ipv5
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<=# ww3 1) of wild3 {
                            GHC.Types.False
                            -> case ipv4 of wild4 { GHC.Types.C# c# ->
                               let {
                                 x :: GHC.Prim.Int# = GHC.Prim.ord# c#
                               } in
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x 65536) of wild5 {
                                 GHC.Types.False
                                 -> let {
                                      i# :: GHC.Prim.Int# = GHC.Prim.+# ww1 ww2
                                    } in
                                    let {
                                      x# :: GHC.Prim.Int# = GHC.Prim.-# x 65536
                                    } in
                                    case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww
                                           i#
                                           (GHC.Prim.narrow16Word#
                                              (GHC.Prim.int2Word#
                                                 (GHC.Prim.+#
                                                    (GHC.Prim.uncheckedIShiftRA# x# 10)
                                                    55296)))
                                           w1 of s2# { DEFAULT ->
                                    case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww
                                           (GHC.Prim.+# i# 1)
                                           (GHC.Prim.narrow16Word#
                                              (GHC.Prim.int2Word#
                                                 (GHC.Prim.+# (GHC.Prim.andI# x# 1023) 56320)))
                                           s2# of s2#1 { DEFAULT ->
                                    $wa3
                                      ww
                                      ww1
                                      (GHC.Prim.+# ww2 2)
                                      (GHC.Prim.-# ww3 2)
                                      ipv5
                                      s2#1 } }
                                 GHC.Types.True
                                 -> case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww
                                           (GHC.Prim.+# ww1 ww2)
                                           (GHC.Prim.narrow16Word# (GHC.Prim.int2Word# x))
                                           w1 of s2# { DEFAULT ->
                                    $wa3
                                      ww
                                      ww1
                                      (GHC.Prim.+# ww2 1)
                                      (GHC.Prim.-# ww3 1)
                                      ipv5
                                      s2# } } }
                            GHC.Types.True
                            -> case GHC.Prim.newByteArray#
                                      @ s
                                      224
                                      w1 of ds4 { (#,#) ipv8 ipv9 ->
                               (# ipv8,
                                  GHC.Types.:
                                    @ Data.Text.Internal.Text
                                    (Data.Text.Internal.Text
                                       ww
                                         `cast`
                                       (UnivCo mkUnsafeCo representational (GHC.Prim.MutableByteArray#
                                                                              s) GHC.Prim.ByteArray#)
                                       ww1
                                       ww2)
                                    (case $wa3 ipv9 0 0 112 wild2 ipv8 of ds5 { (#,#) ipv10 ipv11 ->
                                     ipv11 }) #) } } }
                 } in
                 $wa3
                   dt
                   dt1
                   dt2
                   dt3
                   Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_str
                   eta }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fTextShowAdverbProperties_$cshowb ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Data.Text.Internal.Builder.Builder
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case ds of wild { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds1 ->
                 TextShow.Utils.unwordsB
                   (GHC.Types.:
                      @ Data.Text.Internal.Builder.Builder
                      (case ds1 of wild1 {
                         GHC.Base.Nothing
                         -> Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties1
                              `cast`
                            (Trans
                                 (forall s.
                                  <Data.Text.Internal.Builder.Buffer s
                                   -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                                  ->_R <Data.Text.Internal.Builder.Buffer s>_R
                                  ->_R Sym (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R))
                                 (Sym (Data.Text.Internal.Builder.NTCo:Builder[0])))
                         GHC.Base.Just x
                         -> (Arhelk.Russian.Lemma.Data.Adjective.$fTextShowAdjectiveDegree2
                               x)
                              `cast`
                            (Trans
                                 (forall s.
                                  <Data.Text.Internal.Builder.Buffer s
                                   -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                                  ->_R <Data.Text.Internal.Builder.Buffer s>_R
                                  ->_R Sym (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R))
                                 (Sym (Data.Text.Internal.Builder.NTCo:Builder[0]))) })
                      (GHC.Types.[] @ Data.Text.Internal.Builder.Builder)) }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fTextShowAdverbProperties_$cshowbList ::
    [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
    -> Data.Text.Internal.Builder.Builder
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ eta :: [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties] ->
                 case eta of wild {
                   []
                   -> Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties2
                        `cast`
                      (Trans
                           (forall s.
                            <Data.Text.Internal.Builder.Buffer s
                             -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                            ->_R <Data.Text.Internal.Builder.Buffer s>_R
                            ->_R Sym (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R))
                           (Sym (Data.Text.Internal.Builder.NTCo:Builder[0])))
                   : x xs
                   -> let {
                        ds :: Data.Text.Internal.Builder.Builder
                        = case x of wild1 { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds1 ->
                          TextShow.Utils.unwordsB
                            (GHC.Types.:
                               @ Data.Text.Internal.Builder.Builder
                               (case ds1 of wild2 {
                                  GHC.Base.Nothing
                                  -> Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties1
                                       `cast`
                                     (Trans
                                          (forall s.
                                           <Data.Text.Internal.Builder.Buffer s
                                            -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                                           ->_R <Data.Text.Internal.Builder.Buffer s>_R
                                           ->_R Sym (GHC.ST.NTCo:ST[0]
                                                         <s>_N <[Data.Text.Internal.Text]>_R))
                                          (Sym (Data.Text.Internal.Builder.NTCo:Builder[0])))
                                  GHC.Base.Just x1
                                  -> (Arhelk.Russian.Lemma.Data.Adjective.$fTextShowAdjectiveDegree2
                                        x1)
                                       `cast`
                                     (Trans
                                          (forall s.
                                           <Data.Text.Internal.Builder.Buffer s
                                            -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                                           ->_R <Data.Text.Internal.Builder.Buffer s>_R
                                           ->_R Sym (GHC.ST.NTCo:ST[0]
                                                         <s>_N <[Data.Text.Internal.Text]>_R))
                                          (Sym (Data.Text.Internal.Builder.NTCo:Builder[0]))) })
                               (GHC.Types.[] @ Data.Text.Internal.Builder.Builder)) }
                      } in
                      let {
                        ds1 :: Data.Text.Internal.Builder.Builder
                        = Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_go xs
                      } in
                      (\ @ s
                         eta1 :: Data.Text.Internal.Builder.Buffer s
                                 -> GHC.ST.ST s [Data.Text.Internal.Text] ->
                       let {
                         eta2 :: Data.Text.Internal.Builder.Buffer s
                                 -> GHC.ST.ST s [Data.Text.Internal.Text]
                         = ds `cast` (Data.Text.Internal.Builder.NTCo:Builder[0])
                             @ s
                             (ds1 `cast` (Data.Text.Internal.Builder.NTCo:Builder[0]) @ s eta1)
                       } in
                       \ eta3 :: Data.Text.Internal.Builder.Buffer s
                         eta4 :: GHC.Prim.State# s[OneShot] ->
                       case eta3 of wild1 { Data.Text.Internal.Builder.Buffer dt dt1 dt2 dt3 ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<=# 2 dt3) of wild2 {
                         GHC.Types.False
                         -> case dt2 of wild3 {
                              DEFAULT
                              -> (# eta4,
                                    GHC.Types.:
                                      @ Data.Text.Internal.Text
                                      (Data.Text.Internal.Text
                                         dt
                                           `cast`
                                         (UnivCo mkUnsafeCo representational (GHC.Prim.MutableByteArray#
                                                                                s) GHC.Prim.ByteArray#)
                                         dt1
                                         wild3)
                                      (case GHC.Prim.newByteArray#
                                              @ s
                                              224
                                              eta4 of ds2 { (#,#) ipv1 ipv2 ->
                                       case GHC.Prim.writeWord16Array#
                                              @ s
                                              ipv2
                                              0
                                              __word 91
                                              ipv1 of s2# { DEFAULT ->
                                       case (eta2
                                               (Data.Text.Internal.Builder.Buffer @ s ipv2 0 1 111))
                                              `cast`
                                            (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R)
                                              s2# of ds3 { (#,#) ipv4 ipv5 ->
                                       ipv5 } } }) #)
                              0
                              -> case GHC.Prim.newByteArray#
                                        @ s
                                        224
                                        eta4 of ds2 { (#,#) ipv1 ipv2 ->
                                 case GHC.Prim.writeWord16Array#
                                        @ s
                                        ipv2
                                        0
                                        __word 91
                                        ipv1 of s2# { DEFAULT ->
                                 (eta2 (Data.Text.Internal.Builder.Buffer @ s ipv2 0 1 111))
                                   `cast`
                                 (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R)
                                   s2# } } }
                         GHC.Types.True
                         -> case GHC.Prim.writeWord16Array#
                                   @ s
                                   dt
                                   (GHC.Prim.+# dt1 dt2)
                                   __word 91
                                   eta4 of s2# { DEFAULT ->
                            (eta2
                               (Data.Text.Internal.Builder.Buffer
                                  @ s
                                  dt
                                  dt1
                                  (GHC.Prim.+# dt2 1)
                                  (GHC.Prim.-# dt3 1)))
                              `cast`
                            (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R)
                              s2# } } })
                        `cast`
                      (Trans
                           (forall s.
                            <Data.Text.Internal.Builder.Buffer s
                             -> GHC.ST.ST s [Data.Text.Internal.Text]>_R
                            ->_R <Data.Text.Internal.Builder.Buffer s>_R
                            ->_R Sym (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R))
                           (Sym (Data.Text.Internal.Builder.NTCo:Builder[0]))) }) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fTextShowAdverbProperties_$s$dmshowbPrec ::
    GHC.Types.Int
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> Data.Text.Internal.Builder.Builder
  {- Arity: 2, Strictness: <L,A>,
     Unfolding: InlineRule (-1, True, True)
                (\ ds :: GHC.Types.Int
                   eta :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_$cshowb
                   eta) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $fTextShowAdverbProperties_go ::
    [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
    -> Data.Text.Internal.Builder.Builder
  {- Arity: 1, Strictness: <S,1*U> -}
974ee67da758b79a2a3b4db2c0b6646a
  $fTextShowAdverbProperties_str :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "[]"#) -}
ff618b3b0123eb6dfa86004cd74b2557
  $w$c/= ::
    GHC.Base.Maybe Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Base.Maybe
         Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.Maybe
                           Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
                   ww1 :: GHC.Base.Maybe
                            Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree ->
                 case ww of wild {
                   GHC.Base.Nothing
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a3
                   -> case ww1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1
                        -> case a3 of wild2 {
                             Arhelk.Russian.Lemma.Data.Adjective.PositiveDegree
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Arhelk.Russian.Lemma.Data.Adjective.PositiveDegree
                                  -> GHC.Types.False }
                             Arhelk.Russian.Lemma.Data.Adjective.ComparitiveDegree
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Arhelk.Russian.Lemma.Data.Adjective.ComparitiveDegree
                                  -> GHC.Types.False }
                             Arhelk.Russian.Lemma.Data.Adjective.SuperlativeDegree
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Arhelk.Russian.Lemma.Data.Adjective.SuperlativeDegree
                                  -> GHC.Types.False } } } }) -}
47326ade82ee91d3e667d1e7755390f3
  $w$cshow ::
    GHC.Base.Maybe Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.Maybe
                           Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties3
                      (case ww of wild {
                         GHC.Base.Nothing
                         -> Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties7
                         GHC.Base.Just b1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              GHC.Show.$fShowMaybe1
                              (Arhelk.Russian.Lemma.Data.Adjective.$w$cshowsPrec1
                                 b1
                                 Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties6) }))) -}
68f0c3c70a1620e0f89e01d1c4e6569f
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.Maybe
         Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Base.Maybe
                            Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
                       Arhelk.Russian.Lemma.Data.Adjective.$fShowAdjectiveDegree
                       Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties5
                       ww1
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties3
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties2
                                x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
4d09c922becd223ef654de80a6d9abab
  $wa ::
    (Data.Text.Internal.Builder.Buffer s
     -> GHC.ST.ST s [Data.Text.Internal.Text])
    -> GHC.Prim.MutableByteArray# s
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# s
    -> (# GHC.Prim.State# s, [Data.Text.Internal.Text] #)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ s
                   w :: Data.Text.Internal.Builder.Buffer s
                        -> GHC.ST.ST s [Data.Text.Internal.Text]
                   ww :: GHC.Prim.MutableByteArray# s
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   w1 :: GHC.Prim.State# s[OneShot] ->
                 letrec {
                   $wa3 :: GHC.Prim.MutableByteArray# s
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> [GHC.Types.Char]
                           -> GHC.Prim.State# s
                           -> (# GHC.Prim.State# s, [Data.Text.Internal.Text] #)
                     {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><S,1*U><L,U>,
                        Inline: [0] -}
                   = \ ww4 :: GHC.Prim.MutableByteArray# s
                       ww5 :: GHC.Prim.Int#
                       ww6 :: GHC.Prim.Int#
                       ww7 :: GHC.Prim.Int#
                       w2 :: [GHC.Types.Char]
                       w3 :: GHC.Prim.State# s[OneShot] ->
                     case w2 of wild1 {
                       []
                       -> (w (Data.Text.Internal.Builder.Buffer @ s ww4 ww5 ww6 ww7))
                            `cast`
                          (GHC.ST.NTCo:ST[0] <s>_N <[Data.Text.Internal.Text]>_R)
                            w3
                       : ipv4 ipv5
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<=# ww7 1) of wild2 {
                            GHC.Types.False
                            -> case ipv4 of wild3 { GHC.Types.C# c# ->
                               let {
                                 x :: GHC.Prim.Int# = GHC.Prim.ord# c#
                               } in
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x 65536) of wild4 {
                                 GHC.Types.False
                                 -> let {
                                      i# :: GHC.Prim.Int# = GHC.Prim.+# ww5 ww6
                                    } in
                                    let {
                                      x# :: GHC.Prim.Int# = GHC.Prim.-# x 65536
                                    } in
                                    case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww4
                                           i#
                                           (GHC.Prim.narrow16Word#
                                              (GHC.Prim.int2Word#
                                                 (GHC.Prim.+#
                                                    (GHC.Prim.uncheckedIShiftRA# x# 10)
                                                    55296)))
                                           w3 of s2# { DEFAULT ->
                                    case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww4
                                           (GHC.Prim.+# i# 1)
                                           (GHC.Prim.narrow16Word#
                                              (GHC.Prim.int2Word#
                                                 (GHC.Prim.+# (GHC.Prim.andI# x# 1023) 56320)))
                                           s2# of s2#1 { DEFAULT ->
                                    $wa3
                                      ww4
                                      ww5
                                      (GHC.Prim.+# ww6 2)
                                      (GHC.Prim.-# ww7 2)
                                      ipv5
                                      s2#1 } }
                                 GHC.Types.True
                                 -> case GHC.Prim.writeWord16Array#
                                           @ s
                                           ww4
                                           (GHC.Prim.+# ww5 ww6)
                                           (GHC.Prim.narrow16Word# (GHC.Prim.int2Word# x))
                                           w3 of s2# { DEFAULT ->
                                    $wa3
                                      ww4
                                      ww5
                                      (GHC.Prim.+# ww6 1)
                                      (GHC.Prim.-# ww7 1)
                                      ipv5
                                      s2# } } }
                            GHC.Types.True
                            -> case GHC.Prim.newByteArray#
                                      @ s
                                      224
                                      w3 of ds3 { (#,#) ipv8 ipv9 ->
                               (# ipv8,
                                  GHC.Types.:
                                    @ Data.Text.Internal.Text
                                    (Data.Text.Internal.Text
                                       ww4
                                         `cast`
                                       (UnivCo mkUnsafeCo representational (GHC.Prim.MutableByteArray#
                                                                              s) GHC.Prim.ByteArray#)
                                       ww5
                                       ww6)
                                    (case $wa3 ipv9 0 0 112 wild1 ipv8 of ds4 { (#,#) ipv10 ipv11 ->
                                     ipv11 }) #) } } }
                 } in
                 $wa3 ww ww1 ww2 ww3 (GHC.Types.[] @ GHC.Types.Char) w1) -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  $wgo ::
    [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
    -> (# GHC.Base.Maybe
            Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
15d27584ad5ef7c1c7f524c0f64c9cfe
  data AdverbProperties
    = AdverbProperties {_adverbDegree :: GHC.Base.Maybe
                                           Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree}
    Promotable
f11d7cfd203696b971f1cea4f6ac82b0
  _adverbDegree ::
    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> GHC.Base.Maybe
         Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
  RecSel Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 case ds of wild { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds1 ->
                 ds1 }) -}
d357e305607772cede2f814a352574e5
  adverbDegree ::
    GHC.Base.Functor f =>
    (GHC.Base.Maybe Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
     -> f (GHC.Base.Maybe
             Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree))
    -> Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
    -> f Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><L,U(1*U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor f
                   f1 :: GHC.Base.Maybe
                           Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
                         -> f (GHC.Base.Maybe
                                 Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree)
                   a3 :: Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ (GHC.Base.Maybe
                        Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree)
                   @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                   (\ x :: GHC.Base.Maybe
                             Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree ->
                    case a3 of wild { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds ->
                    Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties x })
                   (f1
                      (case a3 of wild { Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties ds ->
                       ds }))) -}
instance GHC.Classes.Eq [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
  = Arhelk.Russian.Lemma.Data.Adverb.$fEqAdverbProperties
instance GHC.Base.Monoid [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
  = Arhelk.Russian.Lemma.Data.Adverb.$fMonoidAdverbProperties
instance GHC.Show.Show [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
  = Arhelk.Russian.Lemma.Data.Adverb.$fShowAdverbProperties
instance TextShow.Classes.TextShow [Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties]
  = Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties
"SPEC/Arhelk.Russian.Lemma.Data.Adverb $dmshowbPrec @ AdverbProperties" [ALWAYS] forall $dTextShow :: TextShow.Classes.TextShow
                                                                                                        Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
  TextShow.Classes.$dmshowbPrec @ Arhelk.Russian.Lemma.Data.Adverb.AdverbProperties
                                $dTextShow
  = Arhelk.Russian.Lemma.Data.Adverb.$fTextShowAdverbProperties_$s$dmshowbPrec
"SPEC/Arhelk.Russian.Lemma.Data.Adverb $fEqMaybe_$c== @ AdjectiveDegree" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                                                                   Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
  GHC.Base.$fEqMaybe_$c== @ Arhelk.Russian.Lemma.Data.Adjective.AdjectiveDegree
                          $dEq
  = Arhelk.Russian.Lemma.Data.Adverb.$fEqAdverbProperties_$s$fEqMaybe_$c==
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

